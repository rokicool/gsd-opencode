name: CI Pipeline

on:
  push:
    branches: ["**"]

permissions:
  contents: read
  packages: write

jobs:
  validate_code:
    name: Validate Code Quality
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "18"
          cache: "npm"
          cache-dependency-path: "gsd-opencode/package.json"

      - name: Install dependencies
        working-directory: ./gsd-opencode
        run: npm install

      - name: Check Node.js syntax
        working-directory: ./gsd-opencode
        run: |
          node -c bin/install.js
          echo "‚úì JavaScript syntax validation passed"

      - name: Validate package.json
        working-directory: ./gsd-opencode
        run: |
          node -e "console.log('‚úì package.json is valid JSON'); JSON.parse(require('fs').readFileSync('package.json', 'utf8'))"

      - name: Check for common issues
        working-directory: ./gsd-opencode
        run: |
          echo "Checking for console.log statements in production code..."
          if grep -r "console\.log" bin/ --exclude-dir=node_modules; then
            echo "‚ö†Ô∏è  Warning: console.log found in bin/install.js"
          else
            echo "‚úì No console.log statements found"
          fi

          echo "Checking file permissions..."
          if [ -x bin/install.js ]; then
            echo "‚úì bin/install.js is executable"
          else
            echo "‚ùå bin/install.js is not executable"
            exit 1
          fi

  validate_gsd:
    name: Validate GSD Compliance
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "18"

      - name: Check GSD-STYLE.md exists
        run: |
          if [ -f "gsd-opencode/GSD-STYLE.md" ]; then
            echo "‚úì GSD-STYLE.md found"
          else
            echo "‚ùå GSD-STYLE.md not found"
            exit 1
          fi

      - name: Validate command structure
        run: |
          echo "Checking command files..."
          command_dir="gsd-opencode/command"
          if [ -d "$command_dir" ]; then
            for cmd_file in "$command_dir"/gsd/*.md; do
              if [ -f "$cmd_file" ]; then
                echo "Checking $cmd_file..."

                # Check for required YAML frontmatter
                if ! grep -q "^name:" "$cmd_file"; then
                  echo "‚ùå Missing 'name:' in $cmd_file"
                  exit 1
                fi

                if ! grep -q "^description:" "$cmd_file"; then
                  echo "‚ùå Missing 'description:' in $cmd_file"
                  exit 1
                fi

                # Check for required sections
                if ! grep -q "<objective>" "$cmd_file"; then
                  echo "‚ùå Missing <objective> section in $cmd_file"
                  exit 1
                fi

                echo "‚úì $cmd_file structure valid"
              fi
            done
          else
            echo "‚ö†Ô∏è  No commands directory found"
          fi

      - name: Validate workflow structure
        run: |
          echo "Checking workflow files..."
          workflows_dir="gsd-opencode/get-shit-done/workflows"
          if [ -d "$workflows_dir" ]; then
            for workflow_file in "$workflows_dir"/*.md; do
              if [ -f "$workflow_file" ]; then
                echo "Checking $workflow_file..."

                # Check for semantic XML tags (not generic ones)
                if grep -q "<section>" "$workflow_file" || grep -q "<item>" "$workflow_file"; then
                  echo "‚ùå Found generic XML tags in $workflow_file"
                  exit 1
                fi

                # Check for proper semantic tags
                if grep -E "<(purpose|when_to_use|process|step)>" "$workflow_file" > /dev/null || \
                   grep -E "<(objective|context|execution_context)>" "$workflow_file" > /dev/null; then
                  echo "‚úì $workflow_file uses semantic XML tags"
                else
                  echo "‚ö†Ô∏è  $workflow_file may need semantic XML tags"
                fi
              fi
            done
          else
            echo "‚ùå Workflows directory not found"
            exit 1
          fi

      - name: Validate file naming conventions
        run: |
          echo "Checking file naming conventions..."

          # Check for kebab-case in markdown files
          find gsd-opencode -name "*.md" -type f | while read file; do
            basename=$(basename "$file" .md)
            if [[ ! "$basename" =~ ^[a-z0-9-]+$ ]] && [[ "$basename" != "README" ]] && [[ "$basename" != "GSD-STYLE" ]] && [[ "$basename" != "DEBUG" ]]; then
              echo "‚ùå File name should be kebab-case: $file"
              exit 1
            fi
          done
          echo "‚úì File naming follows kebab-case convention"

      - name: Check for anti-patterns
        run: |
          echo "Checking for banned patterns..."

          # Check for enterprise patterns
          if grep -r -i "story point\|sprint\|raci\|knowledge transfer" gsd-opencode --exclude-dir=node_modules --exclude="*.md"; then
            echo "‚ö†Ô∏è  Found enterprise patterns - check manually"
          fi

          # Check for temporal language in implementation docs
          for file in gsd-opencode/workflows/*.md; do
            if [ -f "$file" ]; then
              if grep -E "(previously|no longer|instead of|we changed)" "$file" > /dev/null; then
                echo "‚ùå Found temporal language in $file"
                exit 1
              fi
            fi
          done
          echo "‚úì No temporal language found in workflows"

      - name: Validate template structure
        run: |
          echo "Checking template files..."
          templates_dir="gsd-opencode/templates"
          if [ -d "$templates_dir" ]; then
            for template_file in "$templates_dir"/*.md; do
              if [ -f "$template_file" ]; then
                basename=$(basename "$template_file" .md)

                # Check for proper template header
                if ! grep -q "# \[.*\] Template\|# $basename Template\|# $basename" "$template_file"; then
                  echo "‚ö†Ô∏è  $template_file may need proper template header"
                fi

                # Check for placeholder conventions
                if grep -q "\[.*\]" "$template_file" || grep -q "{.*}" "$template_file"; then
                  echo "‚úì $template_file uses proper placeholder conventions"
                fi
              fi
            done
          fi

      - name: Validate reference structure
        run: |
          echo "Checking reference files..."
          refs_dir="gsd-opencode/references"
          if [ -d "$refs_dir" ]; then
            for ref_file in "$refs_dir"/*.md; do
              if [ -f "$ref_file" ]; then
                basename=$(basename "$ref_file" .md)

                # Check for semantic outer containers
                if grep -E "<$basename>" "$ref_file" > /dev/null || \
                   grep -E "<(overview|core_principle|checkpoint_types|principles)>" "$ref_file" > /dev/null; then
                  echo "‚úì $ref_file uses semantic containers"
                else
                  echo "‚ö†Ô∏è  $ref_file may need semantic outer containers"
                fi
              fi
            done
          fi

      - name: Check file count consistency - GSD commands
        run: |
          echo "Checking .md file count consistency for gsd commands..."

          src_files=$(find ./src/get-shit-done/commands/gsd -name "*.md" -type f 2>/dev/null | grep -v "_archive" | sort)
          gsd_files=$(find ./gsd-opencode/command/gsd -name "*.md" -type f 2>/dev/null | grep -v "_archive" | sort)
          
          src_count=$(echo "$src_files" | wc -l)
          gsd_count=$(echo "$gsd_files" | wc -l)

          echo "Source directory (./src/get-shit-done/commands/gsd): $src_count .md files"
          echo "GSD directory (./gsd-opencode/command/gsd): $gsd_count .md files"

          if [ "$src_count" -eq "$gsd_count" ]; then
            echo "‚úì GSD commands file count matches ($src_count files)"
          else
            difference=$((src_count - gsd_count))
            echo "‚ùå GSD commands file count mismatch!"
            echo "   Difference: $difference files"
            if [ "$src_count" -gt "$gsd_count" ]; then
              echo "   Source has $difference more files than GSD directory"
              echo ""
              echo "Files in source but not in GSD directory:"
              comm -23 <(echo "$src_files" | sed 's|.*/||') <(echo "$gsd_files" | sed 's|.*/||')
            else
              echo "   GSD directory has $((-difference)) more files than source"
              echo ""
              echo "Files in GSD directory but not in source:"
              comm -13 <(echo "$src_files" | sed 's|.*/||') <(echo "$gsd_files" | sed 's|.*/||')
            fi
            exit 1
          fi

      - name: Check file count consistency - get-shit-done
        run: |
          echo "Checking .md file count consistency for get-shit-done..."

          src_count=$(find ./src/get-shit-done/get-shit-done -name "*.md" -type f 2>/dev/null | wc -l)
          gsd_count=$(find ./gsd-opencode/get-shit-done -name "*.md" -type f 2>/dev/null | wc -l)

          echo "Source directory (./src/get-shit-done/get-shit-done): $src_count .md files"
          echo "GSD directory (./gsd-opencode/get-shit-done): $gsd_count .md files"

          if [ "$src_count" -eq "$gsd_count" ]; then
            echo "‚úì get-shit-done file count matches ($src_count files)"
          else
            difference=$((src_count - gsd_count))
            echo "‚ùå get-shit-done file count mismatch!"
            echo "   Difference: $difference files"
            if [ "$src_count" -gt "$gsd_count" ]; then
              echo "   Source has $difference more files than GSD directory"
            else
              echo "   GSD directory has $((-difference)) more files than source"
            fi
            exit 1
          fi

      - name: Check forbidden strings in antipatterns
        run: |
          echo "Checking forbidden strings from antipatterns.toml..."
          
          # Install TOML parser
          npm install @iarna/toml
          
          # Create Node.js script to check forbidden strings
          cat > check_forbidden_strings.js << 'EOF'
          const fs = require('fs');
          const path = require('path');
          const toml = require('@iarna/toml');
          
          // Find files matching pattern
          function findFiles(dir, pattern, excludeDirs) {
            const files = [];
            const patternRegex = new RegExp(pattern.replace('*', '.*'));
            
            function traverse(currentDir) {
              const items = fs.readdirSync(currentDir);
              
              for (const item of items) {
                const itemPath = path.join(currentDir, item);
                const stat = fs.statSync(itemPath);
                
                if (stat.isDirectory()) {
                  // Skip excluded directories
                  if (excludeDirs.includes(item)) continue;
                  traverse(itemPath);
                } else if (stat.isFile() && patternRegex.test(item)) {
                  files.push(itemPath);
                }
              }
            }
            
            traverse(dir);
            return files;
          }
          
          try {
            const tomlContent = fs.readFileSync('./assets/antipatterns.toml', 'utf8');
            const config = toml.parse(tomlContent);
            const checklist = config.checklist;
            
            if (!checklist) {
              console.error('‚ùå No [checklist] section found in antipatters.toml');
              process.exit(1);
            }
            
            const folder = checklist.folder || './gsd-opencode/';
            const filePattern = checklist.file || '*.md';
            const excludeDirs = checklist.exclude_dir ? checklist.exclude_dir.split(',').map(d => d.trim()) : [];
            const forbiddenStrings = checklist.forbidden_strings || [];
            
            console.log(`Scanning folder: ${folder}`);
            console.log(`File pattern: ${filePattern}`);
            console.log(`Exclude dirs: ${excludeDirs.join(', ') || 'none'}`);
            console.log(`Forbidden strings: ${forbiddenStrings.length} strings to check`);
            console.log('');
            
            const files = findFiles(folder, filePattern, excludeDirs);
            console.log(`Found ${files.length} files to check`);
            console.log('');
            
            let violationsFound = false;
            
            for (const file of files) {
              const content = fs.readFileSync(file, 'utf8');
              const lines = content.split('\n');
              
              for (const forbiddenString of forbiddenStrings) {
                for (let i = 0; i < lines.length; i++) {
                  if (lines[i].includes(forbiddenString)) {
                    console.log(`‚ùå Found forbidden string "${forbiddenString}" in ${file}:${i + 1}`);
                    console.log(`   Line ${i + 1}: ${lines[i].trim()}`);
                    console.log('');
                    violationsFound = true;
                  }
                }
              }
            }
            
            if (!violationsFound) {
              console.log('‚úì No forbidden strings found');
            } else {
              console.log('‚ùå Forbidden strings detected in files');
              process.exit(1);
            }
            
          } catch (error) {
            console.error('‚ùå Error during check:', error.message);
            process.exit(1);
          }
          EOF
          
          # Run the Node.js script
          node check_forbidden_strings.js
          
          # Clean up
          rm check_forbidden_strings.js

      - name: Final validation summary
        run: |
          echo "=== GSD Validation Summary ==="
          echo "‚úì GSD-STYLE.md exists and accessible"
          echo "‚úì Command structure validated"
          echo "‚úì Workflow structure validated"
          echo "‚úì File naming conventions followed"
          echo "‚úì Anti-patterns check passed"
          echo "‚úì Template structure validated"
          echo "‚úì Reference structure validated"
          echo "‚úì File count consistency checks passed"
          echo ""
          echo "üéâ GSD compliance validation completed successfully!"

  generate_version:
    name: Generate Version
    runs-on: ubuntu-latest
    needs: [validate_code, validate_gsd]
    outputs:
      version: ${{ steps.version.outputs.version }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Generate version
        id: version
        run: |
          echo "Generating version..."

          # Get the latest version tag that is an ancestor of the current commit
          LATEST_TAG=$(git describe --tags --match "v*.*.*" --abbrev=0 HEAD)

          if [ -z "$LATEST_TAG" ]; then
            echo "‚ùå No version tag found in current branch history"
            exit 1
          fi

          BASE_VERSION="${LATEST_TAG#v}"
          echo "Latest version from branch history: $BASE_VERSION"

          # Get current branch name
          BRANCH_NAME="${{ github.ref_name }}"
          echo "Current branch: $BRANCH_NAME"

          # Get first 4 characters of commit SHA
          COMMIT_SHORT="${{ github.sha }}"
          COMMIT_SHORT="${COMMIT_SHORT:0:4}"
          echo "Commit short: $COMMIT_SHORT"

          # Generate version string
          NEW_VERSION="v${BASE_VERSION}-${BRANCH_NAME}-${COMMIT_SHORT}"
          echo "Generated version: $NEW_VERSION"

          # Output version for next jobs
          echo "version=$NEW_VERSION" >> $GITHUB_OUTPUT

  build_and_publish:
    name: Build and Publish Package
    runs-on: ubuntu-latest
    needs: [validate_code, validate_gsd, generate_version]
    permissions:
      contents: read
      packages: write

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "18"
          cache: "npm"
          cache-dependency-path: "gsd-opencode/package.json"

      - name: Install dependencies
        working-directory: ./gsd-opencode
        run: npm install

      - name: Configure npm for GitHub registry
        working-directory: ./gsd-opencode
        run: |
          echo "Configuring npm for GitHub registry..."
          echo "//npm.pkg.github.com/:_authToken=\${{ secrets.GITHUB_TOKEN }}" > .npmrc

      - name: Update package.json for GitHub npm
        working-directory: ./gsd-opencode
        run: |
          VERSION="${{ needs.generate_version.outputs.version }}"
          echo "Updating package.json to version: $VERSION"

          # Remove 'v' prefix for npm version
          NPM_VERSION="${VERSION#v}"
          npm version "$NPM_VERSION" --no-git-tag-version --allow-same-version

          # Update package name to GitHub scoped package
          npm pkg set name='@rokicool/gsd-opencode'

          # Configure publish registry for GitHub
          npm pkg set publishConfig.registry='https://npm.pkg.github.com'

          # Verify update
          UPDATED_VERSION=$(node -p "require('./package.json').version")
          UPDATED_NAME=$(node -p "require('./package.json').name")
          echo "Updated package name to: $UPDATED_NAME"
          echo "Updated package.json version to: $UPDATED_VERSION"

      - name: Build package
        working-directory: ./gsd-opencode
        run: |
          echo "Building package..."
          npm pack
          echo "‚úì Package built"

      - name: Publish to npm registry
        working-directory: ./gsd-opencode
        run: |
          echo "Publishing to GitHub npm registry..."

          TARBALL=$(ls *.tgz)
          VERSION="${{ needs.generate_version.outputs.version }}"

          echo "Publishing $TARBALL with version $VERSION"

          # Publish to GitHub npm registry
          npm publish "$TARBALL" --registry=https://npm.pkg.github.com

          echo "‚úì Published to GitHub npm registry"

  notify:
    name: Build Summary
    runs-on: ubuntu-latest
    needs: [validate_code, validate_gsd, generate_version, build_and_publish]
    if: always()

    steps:
      - name: Build summary
        run: |
          echo "## CI Pipeline Results" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Branch:** ${{ github.ref_name }}" >> $GITHUB_STEP_SUMMARY
          echo "**Commit:** ${{ github.sha }}" >> $GITHUB_STEP_SUMMARY
          echo "**Version:** ${{ needs.generate_version.outputs.version }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          echo "### Job Status" >> $GITHUB_STEP_SUMMARY
          echo "| Job | Status |" >> $GITHUB_STEP_SUMMARY
          echo "|-----|--------|" >> $GITHUB_STEP_SUMMARY
          echo "| Validate Code | ${{ needs.validate_code.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Validate GSD | ${{ needs.validate_gsd.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Generate Version | ${{ needs.generate_version.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Build and Publish | ${{ needs.build_and_publish.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          if [[ "${{ needs.validate_code.result }}" == "success" && "${{ needs.validate_gsd.result }}" == "success" && "${{ needs.generate_version.result }}" == "success" && "${{ needs.build_and_publish.result }}" == "success" ]]; then
            echo "üéâ **Overall Status: SUCCESS**" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "All validations passed and package published to GitHub npm registry successfully." >> $GITHUB_STEP_SUMMARY
          else
            echo "‚ùå **Overall Status: FAILED**" >> $GITHUB_STEP_SUMMARY
          fi
