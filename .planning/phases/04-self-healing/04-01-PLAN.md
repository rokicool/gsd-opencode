---
phase: 04-self-healing
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [src/services/backup-manager.js]
autonomous: true

must_haves:
  truths:
    - BackupManager creates backup folder maintaining original folder structure
    - BackupManager moves overwritten files to backup with date prefix
    - BackupManager keeps last N backups and removes older ones
    - BackupManager handles errors gracefully without failing the entire operation
  artifacts:
    - path: src/services/backup-manager.js
      provides: "Backup creation and retention management"
      exports: ["BackupManager"]
  key_links:
    - from: BackupManager.backupFile
      to: backup directory
      via: "fs.mkdir + fs.rename"
    - from: BackupManager.cleanupOldBackups
      to: backup directory listing
      via: "fs.readdir with date parsing"
---

<objective>
Create BackupManager service that safely backs up files before they are overwritten during repairs.

Purpose: Provide safe backup and retention for destructive repair operations, ensuring users can recover if something goes wrong.
Output: src/services/backup-manager.js with BackupManager class supporting backup creation and retention.
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md

<!-- Phase context from discuss-phase -->
**Repair scope decisions:**
- Confirm for destructive changes only (auto-fix missing, confirm for corrupted)
- No --force flag for repair
- Create backup folder maintaining original folder structure
- Move overwritten files to backup with date prefix
- Keep last N backups (retain history)
- Surgical path replacement only for @gsd-opencode/ references

**Existing patterns from Phase 3:**
- HealthChecker.verifyIntegrity() detects corrupted files
- HealthChecker.verifyFiles() detects missing files
- Three check categories: files, version, integrity

**Service layer pattern (established in Phases 1-3):**
- Constructor injection for dependencies (ScopeManager, Logger)
- Async methods return structured results
- Error handling with context wrapping
- Private methods prefixed with underscore
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create BackupManager class structure</name>
  <files>src/services/backup-manager.js</files>
  <action>
Create src/services/backup-manager.js with BackupManager class following service layer pattern:

1. Import dependencies:
   - fs/promises for file operations
   - path for path manipulation
   - ScopeManager type check in constructor

2. Constructor accepts:
   - scopeManager: ScopeManager instance (required)
   - logger: Logger instance (required)
   - options: { maxBackups: number } (optional, default 5)

3. Validate constructor arguments:
   - Throw if scopeManager is undefined or missing getTargetDir method
   - Throw if logger is undefined or missing debug/info/error methods
   - Set maxBackups with default of 5

4. Class structure with private fields:
   - this._backupDir = path.join(targetDir, '.backups')
   - this._retentionCount = maxBackups

5. Export BackupManager class as named export and default export object

Follow patterns from:
- src/services/scope-manager.js (constructor validation)
- src/services/health-checker.js (service structure)
- src/services/file-ops.js (async error handling)
  </action>
  <verify>
npm run lint 2>&1 | head -20
  </verify>
  <done>
BackupManager class exists with proper constructor validation, imports, and exports. File passes linting.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement backupFile() method</name>
  <files>src/services/backup-manager.js</files>
  <action>
Add backupFile(sourcePath, relativePath) method to BackupManager:

1. Method signature:
   - async backupFile(sourcePath, relativePath)
   - sourcePath: absolute path to file being backed up
   - relativePath: path relative to installation root (preserves structure)

2. Create date-stamped backup:
   - Generate timestamp: new Date().toISOString().split('T')[0] (YYYY-MM-DD format)
   - Create backup path: this._backupDir + '/' + timestamp + '_' + path.basename(relativePath)
   - Create backup subdirectory for nested files (preserve structure)
   - Example: agents/ro-commit.md -> .backups/2026-02-10_ro-commit.md
   - Example: command/gsd/help.md -> .backups/2026-02-10_help.md (flat structure is fine for backup)

3. Implementation steps:
   - Ensure backup directory exists (fs.mkdir recursive)
   - Copy file from sourcePath to backupPath
   - Return backup result with: { success, backupPath, originalPath }

4. Error handling:
   - If file doesn't exist (ENOENT), return success: true with note that no backup needed
   - On copy error, throw with context: "Failed to backup {relativePath}: {error.message}"
   - Log debug messages for operations

5. Avoid:
   - Do NOT use fs.rename (we want to copy, not move - the original gets overwritten later)
   - Do NOT create parent directories for the backup file (unnecessary complexity)
   - Do NOT validate the source file contents (just copy)
  </action>
  <verify>
echo "Test basic backup creation" && node -e "
import('./src/services/backup-manager.js').then(async ({ BackupManager }) => {
  const mockScope = { getTargetDir: () => '/tmp/test-backup' };
  const mockLogger = { debug: () => {}, info: () => {}, error: () => {} };
  const bm = new BackupManager(mockScope, mockLogger, { maxBackups: 3 });
  console.log('BackupManager created successfully');
  console.log('backupFile method exists:', typeof bm.backupFile === 'function');
}).catch(e => console.error(e));
"
  </verify>
  <done>
backupFile() method implemented with proper path handling, error handling, and structured return. Method preserves file structure in backup folder with date prefix.
  </done>
</task>

<task type="auto">
  <name>Task 3: Implement cleanupOldBackups() method</name>
  <files>src/services/backup-manager.js</files>
  <action>
Add cleanupOldBackups() method to maintain backup retention policy:

1. Method signature:
   - async cleanupOldBackups()
   - No parameters needed (uses this._retentionCount)

2. Implementation:
   - Read backup directory contents
   - Filter for files matching backup pattern: starts with date (YYYY-MM-DD)
   - Sort by date descending (newest first)
   - Delete files beyond retention count (keep this._retentionCount newest)
   - Return summary: { cleaned: number, kept: number, errors: [] }

3. Date extraction:
   - Filename format: YYYY-MM-DD_filename.ext
   - Extract date from first 10 characters
   - Parse with new Date(dateString)

4. Error handling:
   - If backup directory doesn't exist, return { cleaned: 0, kept: 0, errors: [] }
   - Log errors for individual file deletions but continue cleanup
   - Collect all errors in errors array for reporting
   - On complete failure, throw with context: "Failed to cleanup old backups: {error.message}"

5. Edge cases:
   - Handle empty backup directory gracefully
   - Handle files without date prefix (ignore them, don't delete)
   - Handle permission errors (log and continue)

6. Avoid:
   - Do NOT delete the entire backup directory
   - Do NOT use synchronous fs methods (use fs/promises)
   - Do NOT require exact filename format beyond date prefix
  </action>
  <verify>
npm run lint src/services/backup-manager.js 2>&1 | grep -E "(error|warning)" | head -10 || echo "Linting passed"
  </verify>
  <done>
cleanupOldBackups() method implemented with retention logic, proper date sorting, and error collection. Method returns structured summary of cleanup operations.
  </done>
</task>

</tasks>

<verification>
1. BackupManager class has proper JSDoc documentation
2. All methods follow async/await pattern
3. Error handling includes context in messages
4. Logger integration for debug/info/error messages
5. Backup naming convention: YYYY-MM-DD_original_filename
6. Retention count configurable (default 5)
7. Backup directory: {targetDir}/.backups/
</verification>

<success_criteria>
- BackupManager can be instantiated with ScopeManager and Logger
- backupFile() creates date-stamped copies in .backups/ directory
- cleanupOldBackups() retains only N newest backups
- All operations are async and return structured results
- Error handling prevents crashes during backup operations
- File follows established service layer patterns
</success_criteria>

<output>
After completion, create `.planning/phases/04-self-healing/04-01-SUMMARY.md` documenting:
- BackupManager API and key methods
- Backup naming convention and retention policy
- Usage examples for repair operations
</output>
