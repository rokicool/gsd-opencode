---
phase: 04-self-healing
plan: 02
type: execute
wave: 2
depends_on: [04-01]
files_modified: [src/services/repair-service.js]
autonomous: true

must_haves:
  truths:
    - RepairService detects missing files using HealthChecker
    - RepairService detects corrupted files using HealthChecker
    - RepairService categorizes issues by type (Missing, Corrupted, Path Issues)
    - RepairService creates backups before overwriting files
    - RepairService shows progress during repair operations
    - RepairService continues on partial failure and reports all results
    - RepairService returns structured result with success/failure counts
  artifacts:
    - path: src/services/repair-service.js
      provides: "Repair orchestration and execution"
      exports: ["RepairService"]
      methods: ["detectIssues()", "repair()"]
  key_links:
    - from: RepairService.detectIssues
      to: HealthChecker.checkAll
      via: "healthChecker.checkAll() with expectedVersion"
    - from: RepairService.repair
      to: BackupManager.backupFile
      via: "backupManager.backupFile() before overwrite"
    - from: RepairService.repair
      to: FileOperations._copyFile
      via: "fileOps._copyFile() for reinstall"
---

<objective>
Create RepairService that orchestrates detection, backup, and repair operations for broken installations.

Purpose: Provide the core repair logic that detects issues and fixes them safely with backups and progress reporting.
Output: src/services/repair-service.js with RepairService class supporting issue detection and repair execution.
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-self-healing/04-01-SUMMARY.md

<!-- Existing services to integrate with -->
@src/services/health-checker.js
@src/services/file-ops.js
@src/services/scope-manager.js

<!-- Phase context -->
**Repair behavior decisions:**
- Confirm for destructive changes only — auto-fix missing files, require confirmation before overwriting corrupted files
- No --force flag — repair should always show confirmation
- No --dry-run flag — use existing check command to preview
- All-or-nothing repairs — show summary and fix everything or nothing

**Output format:**
- Pre-repair summary grouped by issue type: "Missing Files", "Corrupted Files", "Path Issues"
- Show overall progress during repairs (e.g., "Repairing 3 of 12 files...")
- Detailed post-repair report with success/failure status

**Partial failure handling:**
- Continue with remaining repairs if one fails
- Return non-zero exit code when any repairs fail
- Keep successful repairs — partial fix is better than no fix
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create RepairService class structure and detectIssues() method</name>
  <files>src/services/repair-service.js</files>
  <action>
Create src/services/repair-service.js with RepairService class:

1. Import dependencies:
   - fs/promises for file operations
   - path for path manipulation
   - ScopeManager (for path resolution)
   - HealthChecker (for issue detection)
   - BackupManager (from 04-01)
   - FileOperations (for file reinstall)
   - PATH_PATTERNS from lib/constants.js

2. Constructor:
   - scopeManager: ScopeManager instance (required)
   - backupManager: BackupManager instance (required)
   - fileOps: FileOperations instance (required)
   - logger: Logger instance (required)
   - expectedVersion: string (required for version check)
   - Validate all dependencies are provided
   - Store in this.* properties

3. Implement detectIssues() method:
   - async detectIssues() returns categorized issues
   - Use HealthChecker.checkAll() to get check results
   - Parse results and categorize:
     - missingFiles: files that failed file existence check (ENOENT errors)
     - corruptedFiles: files that failed integrity check
     - pathIssues: .md files with incorrect @gsd-opencode/ references
   - Return structured object:
     {
       hasIssues: boolean,
       missingFiles: [{ path, type: 'directory'|'file' }],
       corruptedFiles: [{ path, relative, error }],
       pathIssues: [{ path, relative, currentContent }],
       totalIssues: number
     }

4. For path issue detection:
   - Read .md files and check for @gsd-opencode/ pattern
   - Compare expected path (targetDir + '/') with actual references
   - If mismatch found, add to pathIssues

5. Avoid:
   - Do NOT try to fix issues in detectIssues (detection only)
   - Do NOT require confirmation in detectIssues (CLI handles that)
   - Do NOT modify any files during detection
  </action>
  <verify>
echo "Checking RepairService structure" && node -e "
import('./src/services/repair-service.js').then(async ({ RepairService }) => {
  console.log('RepairService class exists');
  console.log('detectIssues method exists:', typeof RepairService.prototype.detectIssues === 'function');
}).catch(e => console.error('Import failed:', e.message));
"
  </verify>
  <done>
RepairService class created with constructor validation and detectIssues() method that categorizes issues into missing, corrupted, and path issues.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement repair() method with backup and progress</name>
  <files>src/services/repair-service.js</files>
  <action>
Add repair(issues) method to RepairService:

1. Method signature:
   - async repair(issues, options = {})
   - issues: object from detectIssues() with missingFiles, corruptedFiles, pathIssues
   - options: { onProgress, onBackup } callbacks for progress reporting
   - Returns: { success: boolean, results: {}, stats: {} }

2. Repair strategy (two-phase):
   - Phase 1: Fix non-destructive (missing files) - auto, no backup needed
   - Phase 2: Fix destructive (corrupted files, path issues) - backup first

3. Implementation details:

   a. Calculate total operations:
      - missingFiles.length + corruptedFiles.length + pathIssues.length
   
   b. Fix missing files:
      - Get source paths from package installation (resolve from __dirname)
      - Use fileOps._copyFile to reinstall with path replacement
      - Track success/failure for each file
      - Call onProgress({ current, total, operation: 'installing', file })
   
   c. Fix corrupted files (with backup):
      - Call backupManager.backupFile() first
      - Call onBackup({ file, backupPath }) if callback provided
      - Then reinstall using fileOps._copyFile
      - Track success/failure
      - Call onProgress({ current, total, operation: 'replacing', file })
   
   d. Fix path issues:
      - Read file content
      - Perform surgical replacement: replace @gsd-opencode/ with targetDir + '/'
      - Backup before write (use backupManager)
      - Write updated content
      - Track success/failure
      - Call onProgress({ current, total, operation: 'updating-paths', file })

4. Return structure:
   {
     success: boolean (true only if ALL repairs succeeded),
     results: {
       missing: [{ file, success, error }],
       corrupted: [{ file, success, error }],
       paths: [{ file, success, error }]
     },
     stats: {
       total: number,
       succeeded: number,
       failed: number,
       byCategory: { missing: {}, corrupted: {}, paths: {} }
     }
   }

5. Error handling:
   - Continue with remaining repairs if one fails (don't stop on first error)
   - Log all errors but don't throw until end
   - If any repair failed, set success: false
   - Include error message in result for each failed repair

6. Avoid:
   - Do NOT require interactive confirmation (CLI layer handles that)
   - Do NOT show spinner/progress UI (callbacks allow CLI to do that)
   - Do NOT throw on first failure (collect all results)
   - Do NOT use synchronous file operations
  </action>
  <verify>
npm run lint src/services/repair-service.js 2>&1 | grep -E "(error|warning)" | head -10 || echo "Linting passed"
  </verify>
  <done>
repair() method implemented with two-phase repair (non-destructive then destructive), backup integration, progress callbacks, and comprehensive result reporting.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add helper methods for issue analysis</name>
  <files>src/services/repair-service.js</files>
  <action>
Add helper methods to RepairService:

1. generateSummary(issues) method:
   - Takes issues object from detectIssues()
   - Returns formatted summary string for CLI display
   - Format:
     ```
     Missing Files (3):
       - agents directory
       - command/gsd/help.md
       - get-shit-done/templates/summary.md
     
     Corrupted Files (2):
       - agents/ro-commit.md
       - command/gsd/install.md
     
     Path Issues (1):
       - get-shit-done/templates/summary.md
     ```
   - Only include categories with issues > 0
   - Indent file lists with 2 spaces
   - Use relative paths for readability

2. getSourcePath(relativePath) method (private):
   - Resolves source file path from package installation
   - Uses __dirname and path.resolve to find source
   - Returns absolute path to source file in package
   - Throw if source file doesn't exist (package corruption)

3. validateRepairResults(results) method (private):
   - Validates the repair results structure
   - Returns boolean indicating if repairs were successful
   - Logs warnings for any unexpected result structure

4. Export:
   - Named export: RepairService
   - Default export: { RepairService }

5. Add JSDoc documentation:
   - Class-level JSDoc describing purpose
   - Method-level JSDoc for all public methods
   - Parameter and return type documentation
   - Example usage in class JSDoc

6. Follow existing patterns from:
   - src/services/health-checker.js (method documentation style)
   - src/services/file-ops.js (error handling patterns)
  </action>
  <verify>
echo "Testing RepairService integration" && node -e "
import('./src/services/repair-service.js').then(({ RepairService }) => {
  const methods = Object.getOwnPropertyNames(RepairService.prototype).filter(m => m !== 'constructor');
  console.log('RepairService methods:', methods);
  console.log('Has detectIssues:', methods.includes('detectIssues'));
  console.log('Has repair:', methods.includes('repair'));
  console.log('Has generateSummary:', methods.includes('generateSummary'));
}).catch(e => console.error(e.message));
"
  </verify>
  <done>
Helper methods added with proper documentation. RepairService provides complete API for detection, repair, and summary generation.
  </done>
</task>

</tasks>

<verification>
1. RepairService integrates with HealthChecker, BackupManager, FileOperations
2. detectIssues() categorizes issues: missingFiles, corruptedFiles, pathIssues
3. repair() performs two-phase repair with progress callbacks
4. Backups created before destructive operations
5. All repairs attempted even if some fail
6. Structured results with success/failure per file
7. generateSummary() provides CLI-friendly output
8. Full JSDoc documentation
9. Follows service layer patterns
</verification>

<success_criteria>
- RepairService can be instantiated with all required dependencies
- detectIssues() returns categorized issues from HealthChecker results
- repair() fixes issues with backup and progress reporting
- generateSummary() creates human-readable issue summary
- All operations are async with proper error handling
- Service integrates cleanly with existing infrastructure
- Code follows established patterns and conventions
</success_criteria>

<output>
After completion, create `.planning/phases/04-self-healing/04-02-SUMMARY.md` documenting:
- RepairService API and workflow
- Integration points with HealthChecker and BackupManager
- Two-phase repair strategy (non-destructive vs destructive)
- Progress callback system
</output>
