---
phase: 05-lifecycle-management
plan: 02
type: execute
wave: 2
depends_on:
  - 05-01
files_modified:
  - src/services/update-service.js
autonomous: true

must_haves:
  truths:
    - "UpdateService can detect current installed version"
    - "UpdateService can query npm for latest available version"
    - "UpdateService compares versions and determines if update is needed"
    - "UpdateService performs pre-update health check"
    - "UpdateService creates backup before updating"
    - "UpdateService installs new version using FileOperations"
    - "UpdateService performs post-update verification"
  artifacts:
    - path: "src/services/update-service.js"
      provides: "Update orchestration service"
      exports: ["UpdateService"]
  key_links:
    - from: "UpdateService.checkForUpdate()"
      to: "NpmRegistry.getLatestVersion()"
      via: "npmRegistry dependency injection"
    - from: "UpdateService.performUpdate()"
      to: "FileOperations.install()"
      via: "fileOps dependency"
    - from: "UpdateService.performUpdate()"
      to: "BackupManager.createBackup()"
      via: "backupManager dependency"
    - from: "UpdateService.performUpdate()"
      to: "HealthChecker.checkAll()"
      via: "healthChecker dependency (lazy loaded)"
---

<objective>
Create UpdateService for orchestrating the complete update workflow.

Purpose: Provides high-level update operations that coordinate all aspects of updating GSD-OpenCode: detecting current version, checking for updates, performing health checks, creating backups, installing new versions, and verifying results. This is the core business logic for the update command.

Output: src/services/update-service.js with UpdateService class
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@src/services/repair-service.js
@src/services/backup-manager.js
@src/services/file-ops.js
@src/services/scope-manager.js
@src/utils/npm-registry.js
@src/utils/logger.js
@lib/constants.js

# From repair-service.js:
# - Constructor injection pattern with dependency validation
# - Lazy-load HealthChecker to avoid circular dependencies
# - Progress callbacks for UI decoupling
# - Two-phase operations (check then act)

# From research:
# - Update workflow: detect scope → check version → confirm → backup → install → verify
# - Should reuse existing FileOperations for atomic installation
# - Should use existing HealthChecker for pre/post validation
# - Should use existing BackupManager for safety
</context>

<tasks>

<task type="auto">
  <name>Create UpdateService orchestration class</name>
  <files>src/services/update-service.js</files>
  <action>
    Create src/services/update-service.js with UpdateService class following the repair-service.js patterns:

    1. Constructor and Dependencies:
       - Constructor takes dependencies object with: scopeManager, backupManager, fileOps, npmRegistry, logger
       - Validate all dependencies (check required methods exist)
       - Store dependencies as instance properties
       - Lazy-load HealthChecker (follow repair-service pattern)
       - Include packageName option (default 'gsd-opencode', can be '@rokicool/gsd-opencode' for beta)

    2. Core Methods:

       a) `checkForUpdate()` - Check if update is available
          - Get current installed version from ScopeManager (read VERSION file)
          - Get latest version from NpmRegistry
          - Compare versions using npmRegistry.compareVersions
          - Return object:
            {
              currentVersion: string | null,
              latestVersion: string | null,
              updateAvailable: boolean,
              isBeta: boolean,
              error: string | null
            }

       b) `performUpdate(targetVersion?, options?)` - Execute update
          - Parameters:
            * targetVersion: optional specific version (if null, use latest)
            * options: { onProgress?, force? }
          - Steps:
            1. Pre-update health check (if installed)
            2. Create backup using BackupManager
            3. Download and install new version
               - For npm install approach: use child_process to run npm install
               - For direct approach: download tarball and extract
               - RESEARCH says: use npm install -g gsd-opencode@version for global
               - Or npm install gsd-opencode@version for local
            4. Run FileOperations for path replacement (same as install)
            5. Post-update verification
          - Progress callbacks: onProgress({ phase, current, total, message })
          - Return result object with success, stats, errors

       c) `validateUpdate(targetVersion?)` - Pre-flight validation
          - Check if installation exists
          - Check if target version exists
          - Check write permissions
          - Return { valid: boolean, errors: string[] }

    3. Helper Methods (private):
       - `_getCurrentVersion()` - Read VERSION file via ScopeManager
       - `_getHealthChecker()` - Lazy load (copy from repair-service)
       - `_performPreUpdateCheck()` - Run health checks if installed
       - `_performPostUpdateCheck()` - Verify installation after update
       - `_installVersion(version)` - Execute npm install command

    4. Installation Strategy:
       For global updates:
       - Detect if global via scopeManager.isGlobal()
       - Run: npm install -g gsd-opencode@version
       - Then run FileOperations to ensure path replacement

       For local updates:
       - Detect scope
       - Run: npm install gsd-opencode@version (in appropriate directory)
       - Then run FileOperations

    5. Error Handling:
       - Handle permission errors
       - Handle network errors
       - Handle version not found errors
       - Handle installation failures
       - All errors categorized and returned in result

    6. Include comprehensive JSDoc
    7. Export UpdateService as named export
    8. Add default export

    Follow patterns from repair-service.js:
    - Constructor dependency validation
    - Lazy-loaded HealthChecker
    - Progress callbacks
    - Structured result objects
    - Logger usage

    Key difference from repair: UpdateService installs from npm, RepairService reinstalls from local package files.
  </action>
  <verify>
    node -e "
      import { UpdateService } from './src/services/update-service.js';
      import { ScopeManager } from './src/services/scope-manager.js';
      import { BackupManager } from './src/services/backup-manager.js';
      import { FileOperations } from './src/services/file-ops.js';
      import { NpmRegistry } from './src/utils/npm-registry.js';
      import { logger } from './src/utils/logger.js';

      const scope = new ScopeManager({ scope: 'global' });
      const backupManager = new BackupManager(scope, logger);
      const fileOps = new FileOperations(scope, logger);
      const npmRegistry = new NpmRegistry(logger);

      const updateService = new UpdateService({
        scopeManager: scope,
        backupManager,
        fileOps,
        npmRegistry,
        logger
      });

      console.log('UpdateService created successfully');
      updateService.checkForUpdate().then(result => console.log('Update check:', result));
    "
  </verify>
  <done>UpdateService class exists with checkForUpdate, performUpdate, and validateUpdate methods; constructor validates all dependencies; lazy-loads HealthChecker</done>
</task>

</tasks>

<verification>
1. UpdateService can be instantiated with all required dependencies
2. checkForUpdate() returns update status with current and latest versions
3. validateUpdate() checks preconditions before update
4. performUpdate() orchestrates full update workflow
5. Progress callbacks are called during update
6. Pre/post health checks run (when installed)
7. Backups are created before destructive operations
8. All methods have proper JSDoc documentation
9. Error handling prevents crashes and returns meaningful errors
</verification>

<success_criteria>
- src/services/update-service.js exists with UpdateService class
- Can check for available updates comparing current vs latest version
- Can perform full update with backup, install, and verification
- Progress callbacks provide feedback during operations
- Pre/post health checks ensure installation integrity
- Handles both global and local scope updates
- Supports specifying exact target version
- Proper error handling and categorization
- Code follows existing service patterns (repair-service.js style)
</success_criteria>

<output>
After completion, create `.planning/phases/05-lifecycle-management/05-02-SUMMARY.md`
</output>
