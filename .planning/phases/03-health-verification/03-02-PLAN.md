---
phase: 03-health-verification
plan: 02
type: execute
wave: 2
depends_on: ['03-01']
files_modified:
  - src/commands/check.js
  - bin/gsd.js
autonomous: true

must_haves:
  truths:
    - "User can run gsd-opencode check and see installation health"
    - "Check command shows ✓ for passing checks and ✗ for failing checks"
    - "Check command returns exit code 0 for healthy, non-zero for issues"
    - "Check command supports --global, --local, and --verbose flags"
    - "Check command handles 'not installed' case gracefully"
  artifacts:
    - path: "src/commands/check.js"
      provides: "check command with file, version, and integrity verification"
      min_lines: 200
    - path: "bin/gsd.js"
      provides: "CLI registration for check command"
      pattern: ".command('check')"
  key_links:
    - from: "src/commands/check.js"
      to: "src/services/health-checker.js"
      via: "HealthChecker instantiation"
      pattern: "new HealthChecker"
    - from: "src/commands/check.js"
      to: "src/services/scope-manager.js"
      via: "ScopeManager for path resolution"
      pattern: "new ScopeManager"
    - from: "bin/gsd.js"
      to: "src/commands/check.js"
      via: "import and registration"
      pattern: "import.*checkCommand"
---

<objective>
Create check command and register it in the CLI.

Purpose: Implements CLI-03 requirement. Users need a way to verify installation health with clear pass/fail output. This command uses the HealthChecker service to perform verifications and formats results for the user.

Output: Complete check command with CLI registration, supporting all required flags and exit codes.
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/REQUIREMENTS.md
@.planning/phases/03-health-verification/03-01-SUMMARY.md

# Phase 3 requirements:
- CLI-03: User can run gsd-opencode check to verify installation health
- CHECK-01: Check verifies all required files exist
- CHECK-02: Check verifies installed version matches expected version
- CHECK-03: Check detects corrupted or modified files
- CHECK-04: Check provides clear pass/fail output for each verification
- CHECK-05: Check returns appropriate exit codes (0 for healthy, non-zero for issues)

# Existing patterns:
@src/commands/list.js
@src/commands/install.js
@bin/gsd.js
@lib/constants.js
@src/utils/logger.js

# HealthChecker service (from 03-01):
- HealthChecker class accepts ScopeManager in constructor
- Methods: verifyFiles(), verifyVersion(expectedVersion), verifyIntegrity(), checkAll(options)
- Returns structured results with passed boolean

# Exit codes from constants.js:
ERROR_CODES = { SUCCESS: 0, GENERAL_ERROR: 1 }
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create check command</name>
  <files>src/commands/check.js</files>
  <action>
Create src/commands/check.js following the pattern from list.js:

1. Import dependencies:
   - ScopeManager from '../services/scope-manager.js'
   - HealthChecker from '../services/health-checker.js'
   - logger, setVerbose from '../utils/logger.js'
   - ERROR_CODES from '../../lib/constants.js'
   - getPackageVersion helper (reuse logic from bin/gsd.js or create local version)

2. Implement `displayCheckResults(results)` helper:
   - Display heading: "GSD-OpenCode Installation Health"
   - Show separator line
   - For files check:
     * Show "Required Files" section
     * For each check: ✓ "File: agents/ - OK" or ✗ "File: agents/ - Missing"
   - For version check:
     * Show "Version Verification" section
     * ✓ "Version: 1.0.0 - OK" or ✗ "Version: mismatch (installed: 1.0.0, expected: 1.1.0)"
   - For integrity check:
     * Show "File Integrity" section
     * ✓ "agents/ro-commit/SKILL.md - OK" or ✗ "agents/ro-commit/SKILL.md - Modified"

3. Implement `checkScope(scope, options)` helper:
   - Create ScopeManager with given scope
   - Check if installed (scopeManager.isInstalled())
   - If not installed: display "Not installed" message, return appropriate result
   - Create HealthChecker with scopeManager
   - Get expected version from package (use package.json version as expected)
   - Call healthChecker.checkAll({ expectedVersion, verbose })
   - Return results with exit code

4. Implement `checkCommand(options)` main function:
   - Set verbose mode from options
   - Handle global/local flags similar to list.js:
     * If --global: check only global
     * If --local: check only local
     * Else: check both
   - For each scope:
     * Call checkScope(scope, options)
     * Display results using displayCheckResults
   - Aggregate results and determine overall exit code:
     * All passed: exit code 0
     * Any failed: exit code 1 (GENERAL_ERROR)
   - Return exit code

5. Implement error handling:
   - Handle permission errors (EACCES)
   - Handle interrupt signals (AbortPromptError)
   - Handle unexpected errors with helpful messages

6. Export checkCommand as default and named export

Use ✓ (checkmark) and ✗ (x) symbols for pass/fail output.
Use logger.success() for passing checks, logger.error() for failing.
Follow JSDoc style from list.js.
  </action>
  <verify>node -e "import('./src/commands/check.js').then(m => console.log(typeof m.checkCommand))"</verify>
  <done>check.js exists with checkCommand function, exports correctly</done>
</task>

<task type="auto">
  <name>Task 2: Register check command in CLI</name>
  <files>bin/gsd.js</files>
  <action>
Update bin/gsd.js to register the check command:

1. Add import at top:
   ```javascript
   import { checkCommand } from '../src/commands/check.js';
   ```

2. Add check command registration after the list command (around line 185):
   ```javascript
   // Check command
   program
     .command('check')
     .alias('verify')
     .description('Verify GSD-OpenCode installation health')
     .option('-g, --global', 'Check global installation only')
     .option('-l, --local', 'Check local installation only')
     .action(async (options, command) => {
       const globalOptions = command.parent.opts();
       const fullOptions = {
         ...options,
         verbose: globalOptions.verbose || options.verbose
       };

       const exitCode = await checkCommand(fullOptions);
       process.exit(exitCode);
     });
   ```

3. Ensure the command follows the same pattern as other commands:
   - Get globalOptions from command.parent.opts()
   - Merge with local options
   - Call checkCommand and exit with returned code

4. The check command should be placed between list and uninstall commands for logical grouping.
  </action>
  <verify>grep -n "checkCommand" bin/gsd.js | head -5</verify>
  <done>gsd.js imports checkCommand and registers 'check' command with proper options</done>
</task>

</tasks>

<verification>
After both tasks complete:

1. check.js exports checkCommand function
2. gsd.js imports and registers check command
3. Command supports --global, --local, --verbose flags
4. Output shows ✓ and ✗ for pass/fail
5. Exit codes are correct (0 for healthy, 1 for issues)
6. Command handles not-installed case gracefully
</verification>

<success_criteria>
- check.js created with complete verification logic
- Check command displays structured results with ✓/✗ symbols
- gsd.js registers check command with proper flag handling
- Command returns exit code 0 when healthy, non-zero when issues found
- All CHECK-01 through CHECK-05 requirements satisfied
- Code follows established patterns from other commands
</success_criteria>

<output>
After completion, create `.planning/phases/03-health-verification/03-02-SUMMARY.md`
</output>
