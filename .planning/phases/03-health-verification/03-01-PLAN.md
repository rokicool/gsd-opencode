---
phase: 03-health-verification
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/services/health-checker.js
  - src/utils/hash.js
autonomous: true

must_haves:
  truths:
    - "HealthChecker service can verify file existence in installation"
    - "HealthChecker service can verify installed version matches expected version"
    - "HealthChecker service can detect corrupted/modified files via hash comparison"
    - "HealthChecker returns structured results for each check category"
  artifacts:
    - path: "src/services/health-checker.js"
      provides: "Health checking service with verifyFiles(), verifyVersion(), verifyIntegrity() methods"
      min_lines: 150
    - path: "src/utils/hash.js"
      provides: "Hash utility for file integrity checking (SHA-256)"
      min_lines: 50
  key_links:
    - from: "health-checker.js"
      to: "src/services/scope-manager.js"
      via: "ScopeManager dependency injection"
      pattern: "new ScopeManager({ scope })"
    - from: "health-checker.js"
      to: "src/utils/hash.js"
      via: "hash utility import"
      pattern: "import.*hash"
---

<objective>
Create HealthChecker service and hash utility for verifying installation integrity.

Purpose: Phase 3 requires checking installation health. This service provides the core verification logic that the check command will use. It follows the established service layer pattern from ScopeManager and ConfigManager.

Output: HealthChecker service that can verify file existence, version matching, and file integrity.
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/REQUIREMENTS.md

# Phase 3 requirements:
- CHECK-01: Check verifies all required files exist
- CHECK-02: Check verifies installed version matches expected version  
- CHECK-03: Check detects corrupted or modified files
- CHECK-04: Check provides clear pass/fail output for each verification
- CHECK-05: Check returns appropriate exit codes (0 for healthy, non-zero for issues)

# Existing patterns from codebase:
@src/services/scope-manager.js
@src/services/config.js
@lib/constants.js
@src/utils/logger.js

# Required directories from constants.js:
DIRECTORIES_TO_COPY = ['agents', 'command', 'get-shit-done']
VERSION_FILE = 'VERSION'
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create hash utility for file integrity checking</name>
  <files>src/utils/hash.js</files>
  <action>
Create src/utils/hash.js with:

1. `hashFile(filePath)` function that:
   - Returns SHA-256 hash of file contents using crypto module
   - Returns null if file doesn't exist or can't be read
   - Uses fs.readFile and crypto.createHash
   - Handles errors gracefully

2. `hashString(str)` function that:
   - Returns SHA-256 hash of string
   - Useful for comparing expected content

3. Export both functions

Use Node.js built-in `crypto` module. Do NOT add external dependencies.
  </action>
  <verify>node -e "import('./src/utils/hash.js').then(m => console.log(typeof m.hashFile, typeof m.hashString))"</verify>
  <done>hash.js exists with hashFile and hashString functions, imports work correctly</done>
</task>

<task type="auto">
  <name>Task 2: Create HealthChecker service</name>
  <files>src/services/health-checker.js</files>
  <action>
Create src/services/health-checker.js following the service pattern from scope-manager.js:

1. Import dependencies:
   - fs, path from node modules
   - ScopeManager from './scope-manager.js'
   - hashFile from '../utils/hash.js'
   - DIRECTORIES_TO_COPY, VERSION_FILE from '../../lib/constants.js'

2. Define HealthChecker class with constructor accepting ScopeManager:
   - Store scopeManager instance
   - Get target directory from scopeManager.getTargetDir()

3. Implement `verifyFiles()` method:
   - Check if each directory in DIRECTORIES_TO_COPY exists
   - Check if VERSION file exists
   - Return structured result: { passed: boolean, checks: [{ name, passed, path, error? }] }

4. Implement `verifyVersion(expectedVersion)` method:
   - Read VERSION file content
   - Compare with expectedVersion parameter
   - Return structured result: { passed: boolean, installed: string|null, expected: string, checks: [...] }

5. Implement `verifyIntegrity()` method:
   - Calculate hash of key files in each directory
   - For v1, check a sample file from each directory exists and is readable
   - Return structured result: { passed: boolean, checks: [{ file, hash, passed, error? }] }

6. Implement `checkAll(options)` method:
   - Accepts options: { expectedVersion?, verbose? }
   - Runs all three verification methods
   - Returns aggregated result with overall passed status and exit code suggestion
   - Structure: { passed: boolean, exitCode: number, categories: { files, version, integrity } }

7. Export HealthChecker class and default export

Follow the JSDoc documentation style from scope-manager.js.
Include error handling for permission errors and missing files.
  </action>
  <verify>node -e "import('./src/services/health-checker.js').then(m => console.log(typeof m.HealthChecker))"</verify>
  <done>HealthChecker class exists with verifyFiles, verifyVersion, verifyIntegrity, checkAll methods</done>
</task>

</tasks>

<verification>
After both tasks complete:

1. hash.js exports two functions
2. HealthChecker imports and uses hash.js
3. HealthChecker follows established service pattern
4. All methods return structured results with passed boolean
5. Error handling includes permission and file not found cases
</verification>

<success_criteria>
- hash.js created with hashFile and hashString functions
- HealthChecker service created with 4 verification methods
- Service follows constructor injection pattern (receives ScopeManager)
- Methods return structured results suitable for CLI output
- JSDoc comments present for all public methods
</success_criteria>

<output>
After completion, create `.planning/phases/03-health-verification/03-01-SUMMARY.md`
</output>
