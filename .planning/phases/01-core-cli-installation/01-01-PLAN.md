---
phase: 01-core-cli-installation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/utils/logger.js
  - src/utils/path-resolver.js
  - lib/constants.js
autonomous: true

must_haves:
  truths:
    - "Terminal output supports colors and styled text"
    - "Path resolution handles ~ expansion and normalization"
    - "Shared constants are centralized in one file"
  artifacts:
    - path: "src/utils/logger.js"
      provides: "Colored terminal output with chalk"
      exports: ["logger", "colorize"]
    - path: "src/utils/path-resolver.js"
      provides: "Path expansion and traversal protection"
      exports: ["expandPath", "validatePath"]
    - path: "lib/constants.js"
      provides: "Shared constants"
      exports: ["DEFAULT_CONFIG_DIR", "PATH_PATTERNS"]
  key_links:
    - from: "src/utils/logger.js"
      to: "chalk library"
      via: "import"
      pattern: "import chalk from 'chalk'"
    - from: "src/utils/path-resolver.js"
      to: "os.homedir()"
      via: "Node.js os module"
      pattern: "os.homedir()"
---

<objective>
Create foundational utility modules that provide terminal styling and safe path resolution. These utilities have no external dependencies and form the base layer for all other components.

Purpose: Establish consistent output styling and secure path handling patterns used throughout the CLI.
Output: Logger utility, path resolver utility, and constants module.
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/phases/01-core-cli-installation/01-CONTEXT.md
@.planning/research/ARCHITECTURE.md
@.planning/research/SUMMARY.md

## Implementation Notes

From RESEARCH.md:
- Use **chalk (^5.6.2)** for terminal styling — ESM-only, 115k+ dependents
- Path validation is security-critical — must prevent traversal attacks
- Use `path.resolve()` and verify paths remain within intended directory

From ARCHITECTURE.md:
- Utils layer has no dependencies — pure functions
- Path resolver must handle ~ expansion and validate against traversal
- Logger wraps chalk for consistent styling
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create logger utility with chalk</name>
  <files>src/utils/logger.js</files>
  <action>
Create src/utils/logger.js that provides consistent terminal output:

1. Install chalk as dependency: `npm install chalk@^5.6.2`

2. Create the logger module with these capabilities:
   - `info(message)` - Blue info messages with ℹ symbol
   - `success(message)` - Green success messages with ✓ symbol  
   - `warning(message)` - Yellow warning messages with ⚠ symbol
   - `error(message)` - Red error messages with ✗ symbol
   - `debug(message)` - Gray debug messages (only shown with --verbose)
   - `heading(text)` - Bold white heading for sections
   - `dim(text)` - Dimmed text for secondary info
   - `code(text)` - Cyan inline code formatting

3. Support --verbose flag detection via environment or global state
   - Store verbose mode in a module-level variable
   - Provide `setVerbose(boolean)` function
   - In verbose mode, show debug() output and full stack traces

4. All output should go to stderr (not stdout) to avoid polluting piped output
   - Use console.error() for all logging

5. Auto-detect color support and respect NO_COLOR environment variable
   - chalk automatically handles this, but document the behavior

Example usage:
```javascript
import { logger, setVerbose } from './utils/logger.js';
logger.info('Starting installation...');
logger.success('Installation complete');
logger.error('Permission denied', error);
```

Avoid:
- Using console.log() (breaks piping)
- Hardcoding color codes (use chalk)
- Conditional color logic (let chalk handle it)
  </action>
  <verify>
Run: `node -e "import('./src/utils/logger.js').then(m => { m.setVerbose(true); m.logger.info('test'); m.logger.success('works'); })"`
Expected: Should output styled text without errors
  </verify>
  <done>Logger module exports all required functions and outputs colored text correctly</done>
</task>

<task type="auto">
  <name>Task 2: Create path-resolver utility with traversal protection</name>
  <files>src/utils/path-resolver.js</files>
  <action>
Create src/utils/path-resolver.js for safe path resolution:

1. Create functions:
   - `expandPath(pathStr)` - Expand ~ to home directory, resolve relative paths
   - `validatePath(targetPath, allowedBasePath)` - Verify path doesn't escape allowed directory
   - `normalizePath(pathStr)` - Consistent path normalization across platforms
   - `isSubPath(childPath, parentPath)` - Check if child is within parent

2. Implement expandPath:
   - Replace leading ~ with os.homedir()
   - Use path.resolve() for relative path resolution
   - Return absolute, normalized path

3. Implement validatePath (CRITICAL for security):
   - Resolve both target and allowed base to absolute paths
   - Check that target path starts with allowed base path
   - Normalize paths before comparison to handle ../ tricks
   - Throw descriptive error if traversal detected
   - Example attack to block: `../../../etc/passwd`

4. Implement isSubPath:
   - Use path.relative() and check if result starts with '..'
   - Handle edge cases (same path, path separators)

5. Add comprehensive JSDoc comments explaining security implications

Example usage:
```javascript
import { expandPath, validatePath } from './utils/path-resolver.js';
const target = expandPath('~/.config/opencode');
validatePath(target, os.homedir()); // OK
validatePath('/etc/passwd', os.homedir()); // Throws traversal error
```

Security requirements:
- Must reject paths containing null bytes
- Must reject paths that resolve outside allowed directory
- Must handle symlinks safely (resolve before validation)
- Error messages should be clear but not alarming: "Path traversal detected. Use absolute or relative paths within allowed directories."
  </action>
  <verify>
Run test: `node -e "import('./src/utils/path-resolver.js').then(m => { 
  const os = await import('os'); 
  const expanded = m.expandPath('~/.config'); 
  console.log('Expanded:', expanded); 
  try { m.validatePath('/etc/passwd', os.homedir()); } catch(e) { console.log('Correctly blocked:', e.message); }
})"`
Expected: Should expand ~ and block /etc/passwd
  </verify>
  <done>Path resolver correctly expands ~ and blocks path traversal attempts</done>
</task>

<task type="auto">
  <name>Task 3: Create constants module</name>
  <files>lib/constants.js</files>
  <action>
Create lib/constants.js for shared constants:

1. Define and export:
   - `DEFAULT_CONFIG_DIR` - Default global config directory (~/.config/opencode)
   - `LOCAL_CONFIG_DIR` - Local config directory name (.opencode)
   - `VERSION_FILE` - Name of version tracking file (VERSION)
   - `PATH_PATTERNS` - Regex patterns for path replacement in .md files
     - Pattern to match @gsd-opencode/ references
   - `DIRECTORIES_TO_COPY` - Array of source directories ['agents', 'command', 'get-shit-done']
   - `ERROR_CODES` - Exit codes for different failure modes
     - 0: Success
     - 1: General error
     - 2: Permission error
     - 3: Path traversal detected
     - 130: Interrupted (SIGINT)

2. Export as ES module with named exports

3. Add JSDoc comments for each constant explaining its purpose

Example:
```javascript
export const DEFAULT_CONFIG_DIR = '.config/opencode';
export const PATH_PATTERNS = {
  gsdReference: /@gsd-opencode\//g
};
```

Avoid:
- Hardcoding values in multiple places
- Using CommonJS (project uses ESM)
- Mutable exports
  </action>
  <verify>
Run: `node -e "import('./lib/constants.js').then(m => console.log(Object.keys(m)))"`
Expected: Should list all exported constants
  </verify>
  <done>Constants module exports all required values as named exports</done>
</task>

</tasks>

<verification>
After all tasks complete:
1. Run `node -e "import('./src/utils/logger.js')"` - should not throw
2. Run `node -e "import('./src/utils/path-resolver.js')"` - should not throw  
3. Run `node -e "import('./lib/constants.js')"` - should not throw
4. Verify no TypeError or module resolution errors
</verification>

<success_criteria>
- Logger utility provides styled output for info, success, warning, error, debug
- Path resolver safely expands ~ and validates against traversal attacks
- Constants module centralizes all shared values
- All utilities can be imported without errors
- Path traversal attempts are correctly blocked with clear error messages
</success_criteria>

<output>
After completion, create `.planning/phases/01-core-cli-installation/01-01-SUMMARY.md`
</output>
