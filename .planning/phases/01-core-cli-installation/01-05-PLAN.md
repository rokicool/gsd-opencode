---
phase: 01-core-cli-installation
plan: 05
type: execute
wave: 3
depends_on: ["01-02", "01-03", "01-04"]
files_modified:
  - src/commands/install.js
autonomous: true

must_haves:
  truths:
    - "Install command supports --global, --local, and --config-dir flags"
    - "Interactive prompt shown when no flags provided"
    - "Progress indicators display during file operations"
    - "Path replacement performed on .md files during install"
    - "VERSION file created after successful installation"
    - "Existing installation detection with repair/fresh prompt"
    - "Signal interrupts cleanup temp files gracefully"
  artifacts:
    - path: "src/commands/install.js"
      provides: "Install command implementation"
      exports: ["installCommand"]
  key_links:
    - from: "src/commands/install.js"
      to: "src/services/scope-manager.js"
      via: "import"
      pattern: "import { ScopeManager }"
    - from: "src/commands/install.js"
      to: "src/services/file-ops.js"
      via: "import"
      pattern: "import { FileOperations }"
    - from: "src/commands/install.js"
      to: "src/utils/interactive.js"
      via: "import"
      pattern: "import { promptInstallScope }"
    - from: "src/commands/install.js"
      to: "src/utils/logger.js"
      via: "import"
      pattern: "import { logger }"
---

<objective>
Create the install command that orchestrates the installation process. Handles flag parsing, interactive prompts, file operations, and error handling.

Purpose: Provide the main install functionality with all required features (flags, prompts, progress, path replacement, VERSION file).
Output: installCommand function that can be registered with Commander.js.
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/phases/01-core-cli-installation/01-CONTEXT.md
@.planning/phases/01-core-cli-installation/01-02-SUMMARY.md
@.planning/phases/01-core-cli-installation/01-03-SUMMARY.md
@.planning/phases/01-core-cli-installation/01-04-SUMMARY.md
@.planning/research/ARCHITECTURE.md

## Implementation Notes

From ROADMAP (Phase 1 Requirements addressed):
- CLI-01: User can run gsd-opencode install to install the system
- INST-01: Install supports --global flag for global installation
- INST-02: Install supports --local flag for local installation
- INST-03: Install prompts interactively for location if neither flag is provided
- INST-04: Install performs path replacement in .md files
- INST-05: Install supports --config-dir to specify custom directory
- INST-06: Install shows clear progress indicators during file operations
- INST-07: Install creates VERSION file to track installed version
- INST-08: Install validates target paths to prevent path traversal attacks
- INST-09: Install uses atomic operations (temp-then-move)
- INST-10: Install handles permission errors gracefully
- ERROR-02: All commands handle signal interrupts gracefully with cleanup

Dependencies: Plans 01-02, 01-03, 01-04 (all services and utils)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create install command</name>
  <files>src/commands/install.js</files>
  <action>
Create src/commands/install.js with installCommand function:

1. Import dependencies:
   - ScopeManager from '../services/scope-manager.js'
   - ConfigManager from '../services/config.js'
   - FileOperations from '../services/file-ops.js'
   - { logger, setVerbose } from '../utils/logger.js'
   - { promptInstallScope, promptConfirmation, promptRepairOrFresh } from '../utils/interactive.js'

2. Create installCommand(options) function:
   - options: { global: boolean, local: boolean, configDir: string, verbose: boolean }

3. Implement verbose flag handling:
   - Call setVerbose(options.verbose) at start

4. Implement scope determination:
   - If options.global: scope = 'global'
   - Else if options.local: scope = 'local'
   - Else: scope = await promptInstallScope()
   - If scope is null (user cancelled): exit gracefully

5. Create ScopeManager and ConfigManager:
   - scopeManager = new ScopeManager({ scope, configDir: options.configDir })
   - config = new ConfigManager(scopeManager)

6. Check for existing installation:
   - If scopeManager.isInstalled():
     * action = await promptRepairOrFresh()
     * If action === 'cancel': exit gracefully
     * If action === 'fresh': proceed with fresh install
     * If action === 'repair': (defer to Phase 4 - for now treat as fresh)

7. Perform installation:
   - Show starting message with logger.heading()
   - Create FileOperations instance: fileOps = new FileOperations(scopeManager, logger)
   - Get source directory (package root where get-shit-done/ lives)
   - targetDir = scopeManager.getTargetDir()
   - result = await fileOps.install(sourceDir, targetDir)

8. Create VERSION file:
   - version = get version from package.json
   - await config.setVersion(version)

9. Show success message:
   - logger.success('Installation complete')
   - Show summary: files copied, directories, location
   - Show path prefix for reference

10. Handle errors:
    - Try/catch around entire operation
    - On error: logger.error() with helpful message
    - Suggest remedies based on error type:
      * EACCES: suggest --local or sudo
      * ENOSPC: suggest freeing disk space
      * Path traversal: suggest valid path
    - Exit with appropriate error code

11. Export installCommand as default

Command flow:
- Parse options -> Determine scope -> Check existing -> Install -> Create VERSION -> Success

Example usage (will be called by CLI entry point):
import { installCommand } from './commands/install.js';
await installCommand({ global: true, verbose: false });

Error codes:
- 0: Success
- 1: General error
- 2: Permission error
- 130: Interrupted (SIGINT)
  </action>
  <verify>
Test module loads:
node -e "import('./src/commands/install.js').then(m => console.log('installCommand:', typeof m.default))"
Expected: installCommand is a function
  </verify>
  <done>Install command created with flag parsing, prompts, and installation flow</done>
</task>

<task type="auto">
  <name>Task 2: Add error handling and helpful messages</name>
  <files>src/commands/install.js</files>
  <action>
Enhance install command error handling:

1. Create handleError(error) helper function:
   - Categorize errors by code:
     * EACCES (permission denied): Suggest --local flag or sudo
     * ENOENT (file not found): Check source directory exists
     * ENOSPC (disk full): Suggest freeing space
     * Path traversal: Suggest valid path
     * Generic: Show error message with --verbose suggestion

2. Add specific error messages:
   - Permission error:
     "Permission denied: {path}"
     "Suggestion: Try --local for user directory installation, or use sudo for global install"
   
   - Path traversal:
     "Invalid installation path: Path traversal detected"
     "Suggestion: Use absolute or relative paths within allowed directories"
   
   - Disk full:
     "Insufficient disk space for installation"
     "Suggestion: Free up disk space and try again"
   
   - Generic:
     "Installation failed: {message}"
     "Suggestion: Run with --verbose for detailed error information"

3. Ensure exit codes match error types:
   - 0: Success
   - 1: General error
   - 2: Permission error (EACCES)
   - 3: Path traversal
   - 130: Interrupted

4. In verbose mode:
   - Show full stack traces
   - Show detailed operation logs
   - Show intermediate paths and variables

5. Add pre-flight checks:
   - Verify source directory exists before starting
   - Check if we have write permissions to target parent directory
   - Fail fast with clear message if prerequisites not met

6. Handle edge cases:
   - Target directory is a file (not directory)
   - Target directory exists but is not writable
   - Source directory missing required subdirectories

This implements ERROR-01, ERROR-05, and ERROR-07 requirements.
  </action>
  <verify>
Verify error handling code exists (check for EACCES handling and suggestion messages)
  </verify>
  <done>Error handling provides helpful suggestions for common failure modes</done>
</task>

</tasks>

<verification>
After all tasks complete:
1. Run: node -e "import('./src/commands/install.js')" - should not throw
2. Verify installCommand is exported as default
3. Verify all imports resolve correctly
</verification>

<success_criteria>
- Install command accepts --global, --local, --config-dir, and --verbose flags
- Interactive prompt shown when no scope flags provided
- Existing installation detection triggers repair/fresh prompt
- File operations show progress indicators
- Path replacement performed on .md files
- VERSION file created after successful install
- Permission errors show helpful suggestions
- Path traversal blocked with clear error
- Ctrl+C cleans up temp files and exits gracefully
- Appropriate exit codes returned (0 success, 2 permission, 130 interrupted)
</success_criteria>

<output>
After completion, create .planning/phases/01-core-cli-installation/01-05-SUMMARY.md
</output>
