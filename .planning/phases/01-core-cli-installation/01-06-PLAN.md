---
phase: 01-core-cli-installation
plan: 06
type: execute
wave: 4
depends_on: ["01-01", "01-02", "01-03", "01-05"]
files_modified:
  - src/commands/list.js
  - bin/gsd.js
  - bin/gsd-install.js
  - package.json
autonomous: true

must_haves:
  truths:
    - "CLI entry point routes to install and list subcommands"
    - "List command shows installed version, location, and scope"
    - "List command shows 'Not installed' message when nothing installed"
    - "Legacy bin/gsd-install.js maintains backward compatibility"
    - "Global --verbose flag works across all commands"
    - "Consistent branding and colors in all output"
  artifacts:
    - path: "src/commands/list.js"
      provides: "List command implementation"
      exports: ["listCommand"]
    - path: "bin/gsd.js"
      provides: "Main CLI entry point with Commander.js"
      exports: ["CLI program"]
    - path: "bin/gsd-install.js"
      provides: "Legacy compatibility shim"
    - path: "package.json"
      provides: "Updated bin entries"
      contains: '"bin": { "gsd-opencode": "bin/gsd.js" }'
  key_links:
    - from: "bin/gsd.js"
      to: "src/commands/install.js"
      via: "Commander.js command registration"
      pattern: ".command('install').action(installCommand)"
    - from: "bin/gsd.js"
      to: "src/commands/list.js"
      via: "Commander.js command registration"
      pattern: ".command('list').action(listCommand)"
    - from: "bin/gsd-install.js"
      to: "bin/gsd.js"
      via: "require('./gsd.js')"
      pattern: "require('./gsd.js')"
---

<objective>
Create the list command and CLI entry points. List command displays installation status. CLI entry wires all commands together with Commander.js. Legacy shim maintains backward compatibility.

Purpose: Complete the CLI with all entry points and the list command for viewing installation status.
Output: listCommand, bin/gsd.js (main entry), bin/gsd-install.js (legacy shim), updated package.json
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/phases/01-core-cli-installation/01-CONTEXT.md
@.planning/phases/01-core-cli-installation/01-01-SUMMARY.md
@.planning/phases/01-core-cli-installation/01-02-SUMMARY.md
@.planning/phases/01-core-cli-installation/01-03-SUMMARY.md
@.planning/phases/01-core-cli-installation/01-05-SUMMARY.md
@.planning/research/ARCHITECTURE.md
@.planning/research/SUMMARY.md

## Implementation Notes

From ROADMAP (Phase 1 Requirements):
- CLI-06: User can run gsd-opencode list to show installed version and location
- LIST-01: List shows currently installed version
- LIST-02: List shows installation location (global or local path)
- LIST-03: List shows installation scope (global vs local)
- LIST-04: List handles case when not installed with appropriate message
- ERROR-03: All commands support --verbose flag for detailed debugging output
- ERROR-06: CLI shows consistent branding and formatted output using colors

From ARCHITECTURE.md:
- Use Commander.js for CLI framework
- bin/gsd.js is main entry point
- bin/gsd-install.js is legacy compatibility shim
- Support both new and legacy CLI invocation patterns

From CONTEXT.md:
- list command when nothing installed shows informational message (exit code 0) with install hint

Dependencies: All previous plans (01-01 through 01-05)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create list command</name>
  <files>src/commands/list.js</files>
  <action>
Create src/commands/list.js with listCommand function:

1. Import dependencies:
   - ScopeManager from '../services/scope-manager.js'
   - ConfigManager from '../services/config.js'
   - { logger } from '../utils/logger.js'

2. Create listCommand(options) function:
   - options: { global: boolean, local: boolean, verbose: boolean }

3. Handle scope determination:
   - If options.global: check only global scope
   - If options.local: check only local scope
   - Else: check both and show all findings

4. For single scope check:
   - Create ScopeManager with scope
   - Create ConfigManager
   - Get installation info: await config.getInstallationInfo()

5. Display installation info:
   - If installed:
     * logger.heading('Installation Status')
     * logger.info('Scope: {global|local}')
     * logger.info('Location: {path}')
     * logger.info('Version: {version}')
     * Show pathPrefix for reference
   - If not installed:
     * logger.info('Not installed')
     * Show hint: "Run 'gsd-opencode install' to install"

6. For multiple scope check (when no flags):
   - Check global scope
   - Check local scope
   - Display status for each
   - If neither installed: show "Not installed anywhere" + install hint

7. Handle errors:
   - Permission errors checking directories
   - Wrap with context and helpful messages

8. Export listCommand as default

Display format (installed):
```
GSD-OpenCode Installation Status
================================
Scope:    global
Location: ~/.config/opencode/
Version:  1.0.0
```

Display format (not installed):
```
GSD-OpenCode Installation Status
================================
Not installed

Run 'gsd-opencode install' to install
```

Exit codes:
- 0: Success (even if not installed - this is informational, not an error)
- 1: Error checking installation status

Example usage:
import { listCommand } from './commands/list.js';
await listCommand({ global: false, local: false, verbose: false });
  </action>
  <verify>
Test module loads:
node -e "import('./src/commands/list.js').then(m => console.log('listCommand:', typeof m.default))"
Expected: listCommand is a function
  </verify>
  <done>List command created with scope checking and formatted output</done>
</task>

<task type="auto">
  <name>Task 2: Create main CLI entry point with Commander.js</name>
  <files>bin/gsd.js</files>
  <action>
Create bin/gsd.js as the main CLI entry point:

1. Add shebang: #!/usr/bin/env node

2. Import dependencies:
   - { Command } from 'commander'
   - installCommand from '../src/commands/install.js'
   - listCommand from '../src/commands/list.js'
   - { logger } from '../src/utils/logger.js'
   - package.json (for version)

3. Create Commander program:
   - program = new Command()
   - program.name('gsd-opencode')
   - program.description('GSD-OpenCode distribution manager')
   - program.version(packageJson.version)

4. Add global options:
   - .option('-v, --verbose', 'Enable verbose output', false)
   - These are available to all subcommands

5. Register install command:
   - program
     .command('install')
     .description('Install GSD-OpenCode distribution')
     .option('-g, --global', 'Install globally to ~/.config/opencode/')
     .option('-l, --local', 'Install locally to ./.opencode/')
     .option('-c, --config-dir <path>', 'Custom configuration directory')
     .action(async (options) => {
       try {
         await installCommand(options);
       } catch (error) {
         logger.error(error.message);
         process.exit(error.code || 1);
       }
     })

6. Register list command:
   - program
     .command('list')
     .description('Show installation status')
     .option('-g, --global', 'Show global installation only')
     .option('-l, --local', 'Show local installation only')
     .action(async (options) => {
       try {
         await listCommand(options);
       } catch (error) {
         logger.error(error.message);
         process.exit(error.code || 1);
       }
     })

7. Add default behavior:
   - If no command provided and no args: show help
   - If legacy-style args detected: delegate to install
   - program.parse() at end

8. Handle parse errors:
   - Commander shows help on unknown commands
   - Custom error handler for unexpected errors

9. Make file executable:
   - chmod +x bin/gsd.js (or handle via package.json)

Example usage:
node bin/gsd.js install --global
node bin/gsd.js list
node bin/gsd.js --help

Note: Commander handles --help automatically for each command.
  </action>
  <verify>
Test CLI loads:
node bin/gsd.js --help
Expected: Shows help with install and list commands listed
  </verify>
  <done>Main CLI entry point created with install and list commands</done>
</task>

<task type="auto">
  <name>Task 3: Create legacy compatibility shim and update package.json</name>
  <files>bin/gsd-install.js, package.json</files>
  <action>
Create legacy compatibility shim and update package.json:

1. Create bin/gsd-install.js:
   - Add shebang: #!/usr/bin/env node
   - Detect legacy usage patterns:
     * If --global or --local in args: redirect to gsd.js install
     * If no args: redirect to gsd.js install (interactive)
   - Transform args and require('./gsd.js')

   Example implementation:
   ```javascript
   #!/usr/bin/env node
   const args = process.argv.slice(2);
   
   // Legacy: gsd-opencode --global -> gsd-opencode install --global
   if (args.includes('--global') || args.includes('--local') || args.includes('-g') || args.includes('-l') || args.length === 0) {
     // Convert to new command format
     process.argv = [...process.argv.slice(0, 2), 'install', ...args];
   }
   
   require('./gsd.js');
   ```

2. Make legacy shim executable

3. Update package.json:
   - Add "type": "module" (for ESM support)
   - Add "bin" entry:
     ```json
     "bin": {
       "gsd-opencode": "bin/gsd.js",
       "gsd-install": "bin/gsd-install.js"
     }
     ```
   - Add commander as dependency: npm install commander@^12.0.0
   - Ensure all dependencies are listed:
     * commander
     * chalk
     * ora
     * @inquirer/prompts

4. Add engines field:
   ```json
   "engines": {
     "node": ">=18.0.0"
   }
   ```

5. Verify backward compatibility:
   - npx gsd-opencode --global should work
   - npx gsd-opencode --local should work
   - npx gsd-opencode (no args) should trigger interactive install

Legacy usage patterns to support:
- npx gsd-opencode --global -> gsd-opencode install --global
- npx gsd-opencode --local -> gsd-opencode install --local
- npx gsd-opencode -c /custom/path -> gsd-opencode install --config-dir /custom/path
- npx gsd-opencode (no args) -> gsd-opencode install (interactive)
  </action>
  <verify>
1. Check package.json has correct bin entries
2. Check bin/gsd.js is executable or package.json handles it
3. Run: node bin/gsd-install.js --help (should show help via gsd.js)
Expected: Shows help output
  </verify>
  <done>Legacy shim created and package.json updated with bin entries</done>
</task>

</tasks>

<verification>
After all tasks complete:
1. Run: node bin/gsd.js --help (should show commands)
2. Run: node bin/gsd.js list (should show "Not installed")
3. Verify package.json has bin entries
4. Verify all imports in bin/gsd.js resolve
</verification>

<success_criteria>
- bin/gsd.js routes to install and list subcommands
- install command accepts --global, --local, --config-dir, --verbose
- list command shows version, location, and scope
- list command shows "Not installed" when nothing installed
- Legacy bin/gsd-install.js maintains backward compatibility
- --verbose flag works across all commands
- CLI shows consistent branding with colors
- package.json has correct bin entries
- All entry points can be executed without errors
</success_criteria>

<output>
After completion, create .planning/phases/01-core-cli-installation/01-06-SUMMARY.md
</output>
