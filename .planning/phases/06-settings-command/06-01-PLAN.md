---
phase: 06-settings-command
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - gsd-opencode/get-shit-done/lib/config.md
  - gsd-opencode/get-shit-done/lib/agents.md
  - gsd-opencode/agents/gsd-set-profile.md
autonomous: true

must_haves:
  truths:
    - "Per-stage overrides are scoped to a specific profile and do not leak when switching profiles"
    - "Effective stage model resolution (preset + overrides) works for any profile and is backward-compatible with legacy override shapes"
    - "applyProfile() and /gsd-set-profile Edit flow use the same per-profile override semantics"
  artifacts:
    - path: "gsd-opencode/get-shit-done/lib/config.md"
      provides: "Per-profile override schema + effective stage model resolver"
      contains: "getEffectiveStageModels"
    - path: "gsd-opencode/get-shit-done/lib/agents.md"
      provides: "applyProfile() uses effective stage models (including per-profile overrides)"
      contains: "getEffectiveStageModels"
    - path: "gsd-opencode/agents/gsd-set-profile.md"
      provides: "Edit flow persists overrides for the selected profile before applying rewrites"
      contains: "custom_overrides"
  key_links:
    - from: "gsd-opencode/get-shit-done/lib/agents.md"
      to: "gsd-opencode/get-shit-done/lib/config.md"
      via: "applyProfile() uses getEffectiveStageModels(presetName)"
      pattern: "getEffectiveStageModels\\(presetName\\)"
    - from: "gsd-opencode/agents/gsd-set-profile.md"
      to: ".planning/config.json"
      via: "writeConfig() deep-merge overlay"
      pattern: "writeConfig\\(\\)"
    - from: "gsd-opencode/get-shit-done/lib/config.md"
      to: "profiles.custom_overrides.{profile}.{stage}"
      via: "schema + resolver"
      pattern: "custom_overrides"
---

<objective>
Upgrade per-stage overrides to be **per-profile** (scoped overrides), and update all shared libraries/commands to use the new semantics.

Purpose: `/gsd-settings` must let users tune overrides *for the current profile* without those overrides unexpectedly affecting other profiles.

Output:
- config library documents per-profile override schema and effective stage model resolution
- applyProfile() and /gsd-set-profile documentation reflect per-profile overrides
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Phase vision / locked decisions
@.planning/phases/06-settings-command/06-CONTEXT.md

# Prior implementation baseline
@.planning/phases/05-frontmatter-rewriting/05-02-SUMMARY.md

# Files to update
@gsd-opencode/get-shit-done/lib/config.md
@gsd-opencode/get-shit-done/lib/agents.md
@gsd-opencode/agents/gsd-set-profile.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update config schema + effective stage resolver for per-profile overrides</name>
  <files>gsd-opencode/get-shit-done/lib/config.md</files>
  <action>
Update `config.md` so `profiles.custom_overrides` is **per-profile**, not global.

1) **Update schema docs** to describe the new shape:

- Old/legacy (still supported for compatibility):
  - `profiles.custom_overrides.{stage} = modelId`

- New canonical shape (Phase 06):
  - `profiles.custom_overrides.{profile}.{stage} = modelId`

Include an explicit JSON example showing an override scoped to `balanced` only:

```jsonc
{
  "profiles": {
    "active_profile": "balanced",
    "presets": { "...": "..." },
    "custom_overrides": {
      "balanced": {
        "execution": "opencode/minimax-m2.1-free"
      }
    }
  }
}
```

2) **Update `getEffectiveStageModels(presetName)`** to apply overrides from the per-profile location:

- Start from `getPresetConfig(presetName)`
- Determine `profileOverrides` from `config.profiles.custom_overrides[presetName]` (if present)
- Overlay only known stages (`planning|execution|verification`) where override value is a non-empty string

3) **Backward compatibility (legacy override migration OR dual-read):**

To honor the Phase 06 decision “overrides are scoped per profile”, add a documented normalization behavior so legacy configs don’t cause cross-profile leakage:

- If `config.profiles.custom_overrides` looks like the legacy shape (it directly contains `planning`/`execution`/`verification` keys), treat it as overrides for the **current active profile** and migrate it into the per-profile structure:
  - `profiles.custom_overrides.{active_profile}.{stage}`
  - Remove the top-level stage keys after migration
  - This is best-effort; if migration can’t be performed safely, keep behavior but warn.

Document this normalization as either:
- an explicit helper in the library (recommended): `normalizeCustomOverrides(config)` called by `readConfig()` and/or `getEffectiveStageModels()`, OR
- an explicit step inside `getEffectiveStageModels()` before reading overrides.

4) Update all text references in config.md that previously said overrides live at `profiles.custom_overrides.{stage}` so they now reference `profiles.custom_overrides.{profile}.{stage}`.

Goal: after this task, other commands can rely on `getEffectiveStageModels(profileName)` returning the correct mapping for that profile without overrides leaking across profiles.
  </action>
  <verify>
set -euo pipefail

rg -n "getEffectiveStageModels\\(presetName\\)" gsd-opencode/get-shit-done/lib/config.md

# New canonical path should be documented
rg -n "profiles\\.custom_overrides\\.\\{profile\\}\\.\\{stage\\}" gsd-opencode/get-shit-done/lib/config.md

# Legacy-only phrasing should not remain.
# Expected: 0 matches (or matches only inside a clearly labeled "Legacy compatibility" section).
set +e
rg -n "profiles\\.custom_overrides\\.\\{stage\\}" gsd-opencode/get-shit-done/lib/config.md
rc=$?
set -e
if [ "$rc" -eq 0 ]; then
  echo "Legacy-only override path still present"; exit 1
elif [ "$rc" -eq 1 ]; then
  :
else
  echo "rg error (rc=$rc)"; exit "$rc"
fi
  </verify>
  <done>
- config.md describes `profiles.custom_overrides.{profile}.{stage}` as the canonical override location
- getEffectiveStageModels overlays overrides from the per-profile override object for the requested profile
- Legacy override shape is handled explicitly (migration or dual-read) and documented
  </done>
</task>

<task type="auto">
  <name>Task 2: Update applyProfile() + /gsd-set-profile docs to use per-profile overrides</name>
  <files>
gsd-opencode/get-shit-done/lib/agents.md
gsd-opencode/agents/gsd-set-profile.md
  </files>
  <action>
1) Update `gsd-opencode/get-shit-done/lib/agents.md`:

- In `applyProfile(presetName)`, update any comments/text that claim overrides live at `profiles.custom_overrides.{stage}`.
- Ensure applyProfile is documented as applying the effective stage models for the profile being applied, including overrides from `profiles.custom_overrides.{presetName}.{stage}`.

2) Update `/gsd-set-profile` (gsd-set-profile.md) so its override-edit flow is **scoped to the profile being applied**:

- Replace all references like `profiles.custom_overrides.{stage}` with `profiles.custom_overrides.{newProfile}.{stage}`.
- In the Edit flow “Confirming an edited change”, update the writeConfig overlay example to the nested shape:

```jsonc
{
  "profiles": {
    "custom_overrides": {
      "{newProfile}": {
        "planning": "...",
        "execution": "...",
        "verification": "..."
      }
    }
  }
}
```

- Keep the “only write keys for stages the user actually changed” rule, but scope it under `{newProfile}`.

3) Preserve the critical ordering guarantee:

- Any override write(s) must be persisted via `writeConfig()` *before* calling `applyProfile(newProfile)`.

4) Ensure preview and “current configuration” tables explicitly state that they reflect **effective** stage models for the selected profile (preset + per-profile overrides).
  </action>
  <verify>
set -euo pipefail

# No remaining legacy-path references in these files.
# Expected: 0 matches.
set +e
rg -n "custom_overrides\\.(planning|execution|verification)" gsd-opencode/get-shit-done/lib/agents.md gsd-opencode/agents/gsd-set-profile.md
rc=$?
set -e
if [ "$rc" -eq 0 ]; then
  echo "Legacy-only override path still present"; exit 1
elif [ "$rc" -eq 1 ]; then
  :
else
  echo "rg error (rc=$rc)"; exit "$rc"
fi

# applyProfile still uses the effective resolver
rg -n "getEffectiveStageModels" gsd-opencode/get-shit-done/lib/agents.md

# set-profile doc now shows nested overrides by profile.
# Expected: >= 1 match.
rg -n "custom_overrides" gsd-opencode/agents/gsd-set-profile.md
rg -n "\\{newProfile\\}" gsd-opencode/agents/gsd-set-profile.md
  </verify>
  <done>
- applyProfile documentation references per-profile overrides (not global)
- gsd-set-profile Edit flow persists overrides under `profiles.custom_overrides.{newProfile}.*`
- No remaining incorrect documentation claiming overrides are stored at `profiles.custom_overrides.{stage}` (except a clearly labeled legacy compatibility note)
  </done>
</task>

</tasks>

<verification>
- Smoke-check that the docs remain internally consistent:
  - `getEffectiveStageModels()` describes the same override path that `/gsd-set-profile` writes.
  - `applyProfile()` describes reading the same effective resolver output.
</verification>

<success_criteria>
- There is a single canonical override storage path: `profiles.custom_overrides.{profile}.{stage}`.
- Commands/libraries that apply or preview models (applyProfile, gsd-set-profile) align to that path.
- Legacy config shape has a documented compatibility behavior that prevents cross-profile override leakage.
</success_criteria>

<output>
After completion, create `.planning/phases/06-settings-command/06-01-SUMMARY.md`
</output>
