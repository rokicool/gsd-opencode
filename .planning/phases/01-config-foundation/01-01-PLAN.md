---
phase: 01-config-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - gsd-opencode/get-shit-done/lib/config.md
autonomous: true

must_haves:
  truths:
    - "Config changes persist to .planning/config.json and survive session restarts"
    - "Config file is human-readable JSON that can be manually edited"
    - "Invalid profile names produce clear error messages explaining valid options"
    - "Corrupted JSON files recover gracefully with defaults"
    - "Existing config keys (mode, depth, parallelization) are preserved when extending"
  artifacts:
    - path: "gsd-opencode/get-shit-done/lib/config.md"
      provides: "Config read/write/validate helper functions"
      exports: ["readConfig", "writeConfig", "validateProfile", "getActiveProfile", "setActiveProfile"]
  key_links:
    - from: "gsd-opencode/get-shit-done/lib/config.md"
      to: ".planning/config.json"
      via: "JSON file read/write operations"
      pattern: "config\\.json"
---

<objective>
Create a config helper module that manages `.planning/config.json` with read, write, and validation functions for the profile system.

Purpose: Establish the foundation for profile configuration that all future profile commands will use
Output: A reusable config.md library that handles persistence, validation, and error recovery
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-config-foundation/01-CONTEXT.md
@.planning/config.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create config helper module with core functions</name>
  <files>gsd-opencode/get-shit-done/lib/config.md</files>
  <action>
Create a new markdown file that serves as a reusable config helper library. This file will be @-referenced by commands that need config access.

The module should provide these functions (documented as callable procedures):

1. **readConfig()** - Read and parse .planning/config.json
   - Return parsed object or empty defaults if file missing
   - On JSON parse error: warn user, return defaults (don't crash)
   - Auto-heal: if required keys missing, add them with defaults

2. **writeConfig(config)** - Write config to .planning/config.json
   - Pretty-print with 2-space indent
   - Preserve all existing keys (merge, don't replace)
   - Create .planning/ directory if missing (or error with "Run /gsd-new-project first")

3. **validateProfile(profileName)** - Validate a profile name
   - Check against known profiles: quality, balanced, budget
   - Return {valid: true} or {valid: false, error: "message", validOptions: [...]}

4. **getActiveProfile()** - Get current active profile
   - Return active_profile from config, or "balanced" as default

5. **setActiveProfile(profileName)** - Set active profile
   - Validate first, then update config
   - Return success/failure with error message

Config schema to establish:
```json
{
  "mode": "...",           // existing
  "depth": "...",          // existing  
  "parallelization": ...,  // existing
  "profiles": {
    "active_profile": "balanced",
    "custom_overrides": {}  // for future per-stage overrides
  }
}
```

Use snake_case for all new keys. Document the schema in comments at top of file.
  </action>
  <verify>File exists at gsd-opencode/get-shit-done/lib/config.md with all 5 functions documented</verify>
  <done>Config helper module exists with readConfig, writeConfig, validateProfile, getActiveProfile, setActiveProfile functions</done>
</task>

<task type="auto">
  <name>Task 2: Implement error handling and edge cases</name>
  <files>gsd-opencode/get-shit-done/lib/config.md</files>
  <action>
Extend the config module to handle all error scenarios from CONTEXT.md:

1. **Corrupted JSON handling**:
   - Add procedure for detecting and recovering from malformed JSON
   - On parse failure: log warning "Config file corrupted, using defaults"
   - Back up corrupted file to .planning/config.json.bak before overwriting

2. **Auto-heal missing keys**:
   - If profiles section missing, add it with defaults
   - If active_profile missing, set to "balanced"
   - Log what was restored: "Restored missing config keys: profiles.active_profile"

3. **Lenient parsing**:
   - Unknown keys should be preserved (don't strip them)
   - Log warning for unknown keys but continue: "Unknown config key: 'foo' - ignoring"

4. **Directory validation**:
   - If .planning/ doesn't exist, error with: "No .planning directory found. Run /gsd-new-project first."
   - This check happens in writeConfig() before attempting write

5. **Profile validation messages**:
   - Invalid profile: "Invalid profile 'foo'. Valid options: quality, balanced, budget"
   - Include suggestion if close match exists (simple string similarity)

Add examples showing each error recovery scenario.
  </action>
  <verify>Module includes error handling for: corrupted JSON, missing keys, unknown keys, missing directory, invalid profiles</verify>
  <done>Config module handles all error cases gracefully with clear user messages</done>
</task>

<task type="auto">
  <name>Task 3: Add usage documentation and integration examples</name>
  <files>gsd-opencode/get-shit-done/lib/config.md</files>
  <action>
Add a usage section to the config module showing how other commands should integrate:

1. **Usage examples**:
```markdown
## Usage

Reference this file in commands that need config access:
@~/.config/opencode/get-shit-done/lib/config.md

### Reading config
Call readConfig() to get current configuration. Returns object with all keys.

### Changing active profile
1. Call validateProfile(name) first
2. If valid, call setActiveProfile(name)
3. Provide user feedback on success/failure

### Extending config
To add new config sections:
1. Read existing config with readConfig()
2. Add your keys to the object
3. Write back with writeConfig() - existing keys preserved
```

2. **Schema documentation**:
   - Document the full config.json schema
   - Mark which keys are "existing" vs "new in Phase 1"
   - Explain that built-in defaults live in code, not config file

3. **Manual editing notes**:
   - Config file can be manually edited
   - JSON doesn't support comments
   - Invalid edits will be auto-healed on next read
  </action>
  <verify>Module includes Usage section with examples, schema documentation, and manual editing notes</verify>
  <done>Config module is fully documented for integration by other commands</done>
</task>

</tasks>

<verification>
After all tasks complete:
1. File exists: `gsd-opencode/get-shit-done/lib/config.md`
2. Module documents all 5 core functions
3. Error handling covers all CONTEXT.md scenarios
4. Usage examples show integration patterns
5. Schema is documented with existing vs new keys clearly marked
</verification>

<success_criteria>
- Config helper module exists and documents all required functions
- Error recovery is graceful (no crashes on bad input)
- Schema extends existing config.json structure (preserves mode/depth/parallelization)
- Module is ready to be @-referenced by profile commands in Phase 2+
</success_criteria>

<output>
After completion, create `.planning/phases/01-config-foundation/01-01-SUMMARY.md`
</output>
